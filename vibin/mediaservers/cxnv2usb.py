import base64
import threading
import time
import xml
from collections import deque, Counter
from functools import cache
from pathlib import Path
from typing import Iterable, Deque
from urllib.parse import urlparse
from urllib.request import urlopen
from xml.etree import ElementTree

import upnpclient
import xmltodict

from vibin import VibinNotFoundError
from vibin.logger import logger
from vibin.mediaservers import MediaServer
from vibin.models import (
    MediaServerState,
    Album,
    Artist,
    Track,
    UPnPServiceSubscriptions,
    MediaBrowseSingleLevel,
    MediaFolder,
)
from vibin.types import UpdateMessageHandler, MediaId, UPnPProperties, MediaType

# -----------------------------------------------------------------------------
# Implementation of MediaServer, using USB drives attached to a CXNv2.
#
# Vibin won't auto-detect any media library hosted by the CXNv2. To enable this
# feature, use `--media-server` on the command line, giving the friendly name
# of the CXNv2.
#
# Implementation notes:
#
# The CXNv2 provides a simple implementation of ContentDirectory exposing the
# directory and file structure of any attached USB drives. Experimentally:
#   * Playable tracks have type `object.item.audioItem.musicTrack`
#   * Directories with tracks have type `object.container.album.musicAlbum`
#   * Other directories have type `object.container`
# I'm not sure how the CXNv2 would handle directories containing a mix of
# tracks from different albums.
#
# Albums don't seem to come with the artist name or genre, and these are
# inferred from the album's tracks.
#
# Ids generated by the CXNv2 are **not stable** and change when the device
# cycles through standby mode. They come in the following forms:
#   * ContentDirectory ids are, for example, `8:0_1_11_0`. The `0_1_11_0` part
#     represents navigation through the filesystem using 0-based indexes - the
#     zero'th attached device, the first directory, the eleventh subdirectory
#     etc. The number before the colon is incremented when the device cycles
#     through standby mode.
#   * Resource URLs are, for example,
#     `file:///tmp/usm/27/music/Kosheen/Resist/01%20-%20Demonstrate.mp3`. In
#     this example, the `file:///tmp/usm/` appears fixed, the number changes
#     when the device cycles through standby, and the remaining path is just
#     the path through the USB filesystem.
#   * Images are hosted at, for example,
#     `http://<ip-address>:80/album-art-f85f?id=11:11`. The `album-art-f85f`
#     part seems to be fixed but the id parameter changes when the device
#     cycles through standby.
#
# Neither the ContentDirectory nor the images are available while the device is
# in standby mode. Ids and images are cleared when the device is put into
# standby, and only regenerated on demand. If we know that a track lies at
# 0_1_2_3, and we know that the current prefix is '6:', then it is an error to
# request details for '6:0_1_2_3' without first browsing the root ('0'), '6:0',
# '6:0_1', and '6:0_1_2'. Similarly, images don't exist (and aren't assigned an
# id) until their parent directory is browsed for the first time after the
# device comes out of standby. This regeneration process is rather slow,
# presumably while the device extracts images from the playable files.
#
# To work around these issues, this implementation generates synthetic ids for
# albums and tracks and stores a map between generated ids and paths through
# the USB filesystem. When retrieving metadata for an id, it navigates the
# entire path. This allows the synthetic ids to survive a restart of the CXNv2.
# Unfortunately it does take a couple of seconds to play an album or track that
# hasn't been played since the last time the CXNv2 was in standby mode.
#
# Album art is prefetched at startup, and served to the UI as `data:` URIs.
# -----------------------------------------------------------------------------

_xml_namespaces = {
    "didl": "urn:schemas-upnp-org:metadata-1-0/DIDL-Lite/",
    "dc": "http://purl.org/dc/elements/1.1/",
    "upnp": "urn:schemas-upnp-org:metadata-1-0/upnp/",
    "dlna": "urn:schemas-dlna-org:metadata-1-0/",
}

# Represents paths through the USB device by title. Each entry consists of the
# title, and the index amongst siblings with the same title.
_MediaPathPart = tuple[str, int]
_MediaPath = tuple[_MediaPathPart, ...]


class _BrowseResult(object):
    """A result from ContentDirectory.BrowseDirectChildren, representing an
    item in the content directory.
    """

    def __init__(self, element: ElementTree.Element):
        res = element.find("didl:res", namespaces=_xml_namespaces)
        self.id = element.attrib["id"]
        self.parentId = element.attrib["parentID"]
        self.type = _BrowseResult._property(element, "upnp:class")
        self.title = _BrowseResult._property(element, "dc:title")
        self.album = _BrowseResult._property(element, "upnp:album")
        self.artist = _BrowseResult._property(element, "upnp:artist")
        self.genre = _BrowseResult._property(element, "upnp:genre")
        self.original_track_number = _BrowseResult._int_property(
            element, "upnp:originalTrackNumber"
        )
        self.album_art_uri = _BrowseResult._property(element, "upnp:albumArtURI")
        self.duration = (
            res.attrib["duration"] if isinstance(res, ElementTree.Element) else None
        )
        self.resource = _BrowseResult._property(element, "didl:res")

    @staticmethod
    def _property(element, field):
        """Extract a field's value from the given element's XML."""
        find_result = element.find(field, namespaces=_xml_namespaces)
        if isinstance(find_result, ElementTree.Element):
            return find_result.text or None
        else:
            return None

    @staticmethod
    def _int_property(element, field):
        """Extract a field's value from the ElementTree, parsed as an int."""
        as_string = _BrowseResult._property(element, field)
        if as_string:
            return int(as_string)
        else:
            return None


class _MediaIdGenerator(object):
    """Generates short, url-safe MediaIds to represent _MediaPaths, and
    maintains a bidirectional map between the two."""

    def __init__(self, prefix: str = "id"):
        self._lock = threading.Lock()
        self._by_path = dict()
        self._by_id = dict()
        self._next = 0
        self._prefix = prefix

    def get_id(self, path: _MediaPath) -> MediaId:
        """Returns the generated id for the given path, generating a new one if
        necessary."""
        with self._lock:
            if path not in self._by_path:
                generated = f"{self._prefix}{self._next}"
                self._next = self._next + 1
                self._by_path[path] = generated
                self._by_id[generated] = path
            return self._by_path[path]

    def get_path(self, id: MediaId) -> _MediaPath:
        """Returns the path corresponding to the given id, throwing KeyError
        if none."""
        with self._lock:
            return self._by_id[id]


class _Catalogue(object):
    """Indexes all the Tracks, Albums and Artist objects found in the
    ContentDirectory."""

    def __init__(
        self,
        results: Iterable[tuple[_MediaPath, _BrowseResult]],
        artwork: dict[str, str],
    ):
        self.artwork = artwork
        self.id_map = _MediaIdGenerator()

        self.tracks = [
            self.create_track(path, result)
            for (path, result) in results
            if result.type == "object.item.audioItem.musicTrack"
        ]
        self.tracks_by_id = {track.id: track for track in self.tracks}
        self.tracks_by_album_id = _Catalogue._group_tracks_by_album_id(self.tracks)
        self.track_id_by_resource = {
            _Catalogue.stabilize_resource_uri(result.resource): self.id_map.get_id(path)
            for (path, result) in results
            if result.resource and result.type == "object.item.audioItem.musicTrack"
        }

        self.albums = [
            self.create_album(path, result)
            for (path, result) in results
            if result.type == "object.container.album.musicAlbum"
        ]
        self.albums_by_id = {album.id: album for album in self.albums}

        self.artists = [
            self.create_artist(name)
            for name in {result.artist for (path, result) in results if result.artist}
        ]
        self.artists_by_id = {artist.id: artist for artist in self.artists}
        self.artists.sort(key=lambda a: a.title)

    def create_track(self, path: _MediaPath, result: _BrowseResult) -> Track:
        """Creates a new Track with information from this _BrowseResult"""
        return Track(
            id=self.id_map.get_id(path),
            albumId=self.id_map.get_id(path[:-1]),
            title=result.title,
            artist=result.artist,
            album=result.album or "Unknown Album",
            duration=result.duration,
            genre=result.genre,
            album_art_uri=self.artwork.get(result.album_art_uri)
            or result.album_art_uri,
            original_track_number=result.original_track_number,
        )

    def create_album(self, path: _MediaPath, result: _BrowseResult) -> Album:
        """Creates a new Album with information from this _BrowseResult."""
        album_id = self.id_map.get_id(path)
        return Album(
            id=album_id,
            title=result.title,
            artist=result.artist or self._guess_artist(album_id),
            genre=result.genre or self._guess_genre(album_id),
            album_art_uri=self.artwork.get(result.album_art_uri)
            or result.album_art_uri,
        )

    def _guess_artist(self, album_id: MediaId):
        """Infers the artist name from an album's tracks.

        If a single artist is responsible for most of the tracks, assume the
        album is credited to that artist. Otherwise, use the name `Various
        Artists`.
        """
        tracks = self.tracks_by_album_id.get(album_id)
        if not tracks:
            return "Unknown"
        (artist, count) = Counter([t.artist for t in tracks]).most_common(1)[0]
        if artist and count > len(tracks) / 2:
            return artist
        else:
            return "Various Artists"

    def _guess_genre(self, album_id: MediaId):
        """Infers a genre from an album's tracks.

        If most of the tracks share a genre, uses that genre. Otherwise, return
        the string 'Unknown' which the UI expects in the absense of a genre.
        """
        tracks = self.tracks_by_album_id.get(album_id)
        if not tracks:
            return "Unknown"
        (genre, count) = Counter([t.genre for t in tracks]).most_common(1)[0]
        if genre and count > len(tracks) / 2:
            return genre
        else:
            return "Unknown"

    def create_media_folder(self, result: _BrowseResult) -> MediaFolder:
        """Creates a new MediaFolder with information from this _BrowseResult."""
        return MediaFolder(
            title=result.title,
            album_art_uri=result.album_art_uri,
            artist=result.artist,
            genre=result.genre,
        )

    def create_model_object(
        self, path: _MediaPath, result: _BrowseResult
    ) -> Track | Album | MediaFolder:
        """Returns a model object for this _BrowseResult."""
        match result.type:
            case "object.item.audioItem.musicTrack":
                return self.create_track(path, result)
            case "object.container.album.musicAlbum":
                return self.create_album(path, result)
            case _:
                return self.create_media_folder(result)

    def create_artist(self, name: str):
        """Creates an Artist object given a name.

        Ids are synthetic and based simply on the name.
        """
        return Artist(
            id=base64.urlsafe_b64encode(name.encode()),
            title=name,
            genre="Unknown",
            album_art_uri=None,
        )

    @staticmethod
    def _group_tracks_by_album_id(tracks: list[Track]) -> dict[MediaId, list[Track]]:
        out = {}
        for track in tracks:
            if track.albumId not in out:
                out[track.albumId] = []
            out[track.albumId].append(track)

        return out

    @staticmethod
    def stabilize_resource_uri(resource: str):
        """Strips the unstable portion of a resource path, leaving a portion
        which survives standby mode and is still likely to be a unique
        identifier for a track.

        Resource paths are in the form:
        `file:///tmp/usm/27/music/Kosheen/Resist/01%20-%20Demonstrate.mp3`
        ...where the number is unstable. Returns the rest of the path.
        """
        return "/".join(urlparse(resource).path.split("/")[4:])


class CXNv2USB(MediaServer):
    """Implementation of MediaServer using USB storage attached to a Cambridge
    Audio CXNv2 Streamer."""

    model_name = "CXNv2 USB Storage"

    def __init__(
        self,
        device: upnpclient.Device,
        upnp_subscription_callback_base: str | None = None,
        on_update: UpdateMessageHandler | None = None,
    ):
        self._device: upnpclient.Device = device

    @property
    def name(self) -> str:
        return self._device.friendly_name

    @property
    def device(self):
        return self._device

    @property
    def device_state(self) -> MediaServerState:
        return MediaServerState(name=self._device.friendly_name)

    @property
    def device_udn(self) -> str:
        return self._device.udn.removeprefix("uuid:")

    def on_startup(self) -> None:
        pass

    def on_shutdown(self) -> None:
        pass

    # -------------------------------------------------------------------------
    # System

    def clear_caches(self):
        self._catalogue.cache_clear()

    @property
    def url_prefix(self):
        media_location = self.device.location
        parsed_location = urlparse(media_location)

        return f"{parsed_location.scheme}://{parsed_location.netloc}"

    # -------------------------------------------------------------------------
    # Settings - unused in this implementation

    @property
    def all_albums_path(self) -> str | None:
        return None

    @all_albums_path.setter
    def all_albums_path(self, path: str):
        pass

    @property
    def new_albums_path(self) -> str | None:
        return None

    @new_albums_path.setter
    def new_albums_path(self, path: str):
        pass

    @property
    def all_artists_path(self) -> str | None:
        return None

    @all_artists_path.setter
    def all_artists_path(self, path: str):
        pass

    # -------------------------------------------------------------------------
    # Media

    @property
    def albums(self) -> list[Album]:
        """Get details on all Albums on the Media Server."""
        return self._catalogue().albums

    @property
    def new_albums(self) -> list[Album]:
        """Get details on all new Albums on the Media Server.

        Unsupported - just returns an empty list.
        """
        return []

    def album(self, album_id: MediaId) -> Album:
        """Get details on an Album by MediaId."""
        try:
            return self._catalogue().albums_by_id[album_id]
        except KeyError:
            raise VibinNotFoundError(f"Could not find Album with id '{album_id}'")

    def album_tracks(self, album_id: MediaId) -> list[Track]:
        """Get details on all Tracks for an Album on the Media Server."""
        return self._catalogue().tracks_by_album_id.get(album_id) or []

    @property
    def artists(self) -> list[Artist]:
        """Get details on all Artists on the Media Server."""
        return self._catalogue().artists

    def artist(self, artist_id: MediaId) -> Artist:
        """Get details on an Artist by MediaId."""
        try:
            return self._catalogue().artists_by_id[artist_id]
        except KeyError:
            raise VibinNotFoundError(f"Could not find Artist with id '{artist_id}'")

    @property
    def tracks(self) -> list[Track]:
        """Get details on all Tracks on the Media Server."""
        return self._catalogue().tracks

    def track(self, track_id: MediaId) -> Track:
        """Get details on a Track by MediaId."""
        try:
            return self._catalogue().tracks_by_id[track_id]
        except KeyError:
            raise VibinNotFoundError(f"Could not find Track with id '{track_id}'")

    def ids_from_filename(
        self, filename: str, ids: list[MediaType]
    ) -> dict[MediaType, MediaId | None]:
        """Extract Media Ids from the given filename."""
        stable_resource = _Catalogue.stabilize_resource_uri(filename)
        if stable_resource in self._catalogue().track_id_by_resource:
            track_id = self._catalogue().track_id_by_resource[stable_resource]
            album = self._catalogue().tracks_by_id.get(track_id)
            return {"track": track_id, "album": album.albumId if album else None}
        else:
            return {"track": None, "album": None}

    # -------------------------------------------------------------------------
    # Browsing

    def get_path_contents(
        self, path: Path
    ) -> list[MediaFolder | Artist | Album | Track] | Track | None:
        """Retrieve the contents of the given path on the Media Server.

        Following the implementation in asset.py, the path is a sequence of
        titles. If multiple entries have the same title, pick the first.
        """
        media_path: _MediaPath = tuple([(part, 0) for part in path.parts])
        match = self._traverse_path(media_path)

        if match and match.type == "object.item.audioItem.musicTrack":
            return self._catalogue().create_track(media_path, match)
        else:
            contents = []
            title_counter = Counter()
            for child in self._browse_direct_children(match.id if match else "0"):
                title = child.title
                child_path = media_path + ((title, title_counter[title]),)
                title_counter[title] += 1
                model = self._catalogue().create_model_object(child_path, child)
                contents.append(model)
            return contents

    def children(self, parent_id: MediaId = "0") -> MediaBrowseSingleLevel:
        """Retrieve information on all children of the given `parent_id`.

        Vibin's /api/browse/children/ URI returns 404 if no id is provided. Use
        "0" (as specified as the default by the superclass) to represent the
        root.
        """
        if parent_id == "0":
            path = ()
            id = "0"
        else:
            path = self._catalogue().id_map.get_path(parent_id)
            id = self._traverse_path(path).id

        output = MediaBrowseSingleLevel(
            id=parent_id,
            children=[child.__dict__ for child in self._browse_direct_children(id)],
        )
        # Fix up the returned ids to use the synthetic ones
        title_counter = Counter()
        for child in output.children:
            title = child["title"]
            child_path = path + ((title, title_counter[title]),)
            title_counter[title] += 1

            child["directory_id"] = child["id"]
            child["id"] = self._catalogue().id_map.get_id(child_path)
        return output

    def get_metadata(self, id: MediaId):
        """Get Media Server metadata on an item by MediaId."""
        path = self._catalogue().id_map.get_path(id)
        result = self._traverse_path(path)
        try:
            browse_result = self._device.ContentDirectory.Browse(
                ObjectID=result.id,
                BrowseFlag="BrowseMetadata",
                Filter="*",
                StartingIndex=0,
                RequestedCount=0,
                SortCriteria="",
            )
            return browse_result["Result"]
        except upnpclient.soap.SOAPProtocolError:
            raise VibinNotFoundError(f"Could not find media id {id}")

    def get_audio_file_url(self, track_id: MediaId) -> str | None:
        """Get the audio file URL for a track by MediaId."""
        try:
            metadata = self.get_metadata(track_id)
            track_info = xmltodict.parse(metadata)

            audio_files = [
                file
                for file in track_info["DIDL-Lite"]["item"]["res"]
                if file["#text"].endswith(".flac") or file["#text"].endswith(".wav")
            ]

            return audio_files[0]["#text"] if audio_files else None
        except (KeyError, IndexError, xml.parsers.expat.ExpatError, VibinNotFoundError):
            return None

    def _traverse_path(self, parts: _MediaPath) -> _BrowseResult:
        """Traverses a path of titles, returning the _BrowseResult."""
        try:
            directory_id = "0"
            child = None
            for title, index in parts:
                children = self._browse_direct_children(directory_id)
                matching = [child for child in children if child.title == title]
                child = matching[index]
                directory_id = child.id
            return child
        except IndexError:
            raise VibinNotFoundError(f"Could not find path '{parts}'")

    # -------------------------------------------------------------------------
    # UPnP

    def subscribe_to_upnp_events(self) -> None:
        pass

    @property
    def upnp_properties(self) -> UPnPProperties:
        return {}

    @property
    def upnp_subscriptions(self) -> UPnPServiceSubscriptions:
        return {}

    def on_upnp_event(self, service_name: str, event: str):
        pass

    # -------------------------------------------------------------------------
    # Recursively index the ContentDirectory

    @cache
    def _catalogue(self) -> _Catalogue:
        # to_fetch is a queue of pairs containing the path and id of an entry.
        to_fetch: Deque[tuple[_MediaPath, str]] = deque([((), "0")])

        # browse_results is a list of pairs containing the path and result of
        # browsing an entry.
        browse_results: list[tuple[_MediaPath, _BrowseResult]] = []

        processed_ids: set[str] = set()
        artwork_urls: set[str] = set()
        log_interval = 30

        next_log_time = time.time() + log_interval
        while to_fetch:
            path, id = to_fetch.popleft()
            processed_ids.add(id)

            title_counter = Counter()
            for child in self._browse_direct_children(id):
                child_path = path + ((child.title, title_counter[child.title]),)
                title_counter[child.title] += 1

                browse_results.append((child_path, child))

                if child.album_art_uri:
                    artwork_urls.add(child.album_art_uri)
                if (
                    child.type.startswith("object.container")
                    and not child.id in processed_ids
                ):
                    to_fetch.append((child_path, child.id))

                if time.time() > next_log_time:
                    logger.info(
                        f"Still scanning - {len(processed_ids)} directories so far"
                    )
                    next_log_time = time.time() + log_interval

        logger.info("Fetching artwork")
        next_log_time = time.time() + log_interval
        artwork = dict()
        for url in artwork_urls:
            http_response = urlopen(url)
            content_type = http_response.headers["Content-Type"]
            encoded = base64.b64encode(http_response.read()).decode("ascii")
            artwork[url] = f"data:image/{content_type};base64,{encoded}"

            if time.time() > next_log_time:
                logger.info(f"Fetched {len(artwork)} out of {len(artwork_urls)}")
                next_log_time = time.time() + log_interval

        return _Catalogue(browse_results, artwork)

    def _browse_direct_children(self, id) -> list[_BrowseResult]:
        """Fetches children of the given id, using ContentDirectory.Browse."""

        # Note: the ContentDirectory spec says that RequestedCount can be zero
        # to request all entries. CXNv2 doesn't honour this - instead, use a
        # high RequestedCount and potentially repeat the call.
        response = self._device.ContentDirectory.Browse(
            ObjectID=id,
            BrowseFlag="BrowseDirectChildren",
            Filter="*",
            StartingIndex=0,
            RequestedCount=10000,
            SortCriteria="",
        )
        if response["TotalMatches"] > 10000:
            response = self._device.ContentDirectory.Browse(
                ObjectID=id,
                BrowseFlag="BrowseDirectChildren",
                Filter="*",
                StartingIndex=0,
                RequestedCount=response["TotalMatches"],
                SortCriteria="",
            )

        return [
            _BrowseResult(result)
            for result in ElementTree.fromstring(response["Result"])
        ]
